# algorithm

## 1.异或

- 两个数异或相当于2进制位无进制相加

- 0^N == N   N^N == 0

- 异或运算满足交换律和结合律

- 提取一个不为0的数的最右侧的1

  ~~~c#
  a = a & ((~a) +1); 
  ~~~




## 2.排序算法

### 1.归并

![归并排序](./assets/归并排序.png)



### 2.理解归并排序

- 小和问题

  ![image-20230721175411032](./assets/image-20230721175411032.png)



反过来理解:一个数右边比它大的数的和的累加

1 : 4次

3 : 2次

4 : 1次

2 : 1次

5 : 0 次

**比较的时机: 归并排序在merge 的时候比较左右2组数大小时候**



## 3.堆结构

- 完全二叉树
- 大根堆
- 小根堆
- Heapify 方法: 在堆结构上,arr[index]位置的数，能否往下移动
- 优先级队列(小根堆)



## 4.比较器

- 规定2个样本怎么比较大小



## 5.前缀树

![](./assets/5trie、桶排序、排序总结【IT先锋营】.mp4_20230730_211645.150-1690723070226-2.jpg)





## 6.计数排序

![image-20230913143223670](./assets/image-20230913143223670.png)

一个位一个位(个位,十位,百位,千位.....)放在桶里面排序,再取出



## 7.二叉树

### 1.先序,中序,后序

![image-20230914144148571](./assets/image-20230914144148571.png)

### 2.子树

从某一个头节点出发,全部拿出当前节点及其子节点



### 3.非递归方式实现二叉树的先序,中序,后序遍历

#### 1).任何递归函数都可以改成非递归

#### 2).自己设计压栈实现



- 非递归方式实现先序

  ![image-20230918152844073](./assets/image-20230918152844073.png)



- 非递归方式实现后序

  和先序相反的顺序压入一个栈,再取出

- 非递归方式实现中序

  ![image-20230918162114230](./assets/image-20230918162114230.png)





- 一个栈实现后序遍历

![image-20230920092805414](./assets/image-20230920092805414.png)

### 4.二叉树的按层遍历







